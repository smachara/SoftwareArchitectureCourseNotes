Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2022-08-24T00:01:49+02:00

====== 1 Principes SOLID ======
Creado mi√©rcoles 24 agosto 2022

Principes SOLID : 
	[[+1 qu'est-ce que c'est ?]]

	[[+2 SOLID vs STUPID]]

	[[+3 SOLID]]
		S
			Single Responsqbility Principle (SRP) 
			Le principe de responsabilit√© unique 
				L'id√©e derri√®re le SRP est que chaque classe, module ou fonction d'un programme doit avoir une responsabilit√©/un objectif dans le programme.
				"Chaque classe ne doit avoir qu'une seule raison de changer"
				o
					Petites classes avec de petits objectifs
					noms des m√©thodes et des classes bien pr√©cis
						Afin de ne pas inciter √† l'ajout de plus de fonctionnalit√©s. 
						Exemple
							Ordre | User : Ce sont des mod√®les de domaine, pas des services.
							OrderAnalyzer | OrderProcessor : Ce sont des termes g√©n√©riques qui nous am√®nent √† nous retrouver avec plus d'une responsabilit√©.
							OrderTrustabilityChecker | OrderMarginCalculator : Plus pr√©cis. N'ouvre pas la porte √† l'ajout de nouvelles fonctionnalit√©s
				üßø
					Haut niveau de coh√©sion et de robustesse.
					Favoriser la composition de classes (injecter des composants)
					√âviter la duplication du code
				o
					Test simplifi√©
						Une classe avec une seule responsabilit√© aura beaucoup moins de cas de test, ce qui permet de r√©duire les efforts de test.
					Faible couplage
						Moins de fonctionnalit√©s dans une seule classe aura moins de d√©pendances. Par cons√©quent, le couplage sera r√©duit.
					Organisation plus efficace
						Les classes plus petites et bien organis√©es sont plus faciles √† rechercher par un lecteur de code d√©butant que les classes plus grandes.
					Plus simple √† int√©grer
						Les classes, les composants logiciels et les microservices qui n'ont qu'une seule responsabilit√© sont beaucoup plus faciles √† expliquer, √† comprendre et √† mettre en ≈ìuvre que ceux qui offrent une solution pour tout. Cela r√©duit le nombre de bugs, am√©liore votre vitesse de d√©veloppement et rend votre vie de d√©veloppeur de logiciels beaucoup plus facile.
					Plus simple √† maintenir
						En vous assurant que vos classes n'ont qu'une seule responsabilit√©, vous pouvez √©conomiser beaucoup d'efforts dans le d√©veloppement de l'application et cr√©er une architecture plus facile √† maintenir.
				Example
					Supposons que nous √©crivions une application php pour un cabinet de conseil en recrutement. Nous allons cr√©er une classe Resume qui permet au consultant d'obtenir et de d√©finir la technologie et les ann√©es d'exp√©rience dans chaque CV, et de rechercher le r√©sum√© √† partir de la base de donn√©es.
					o
						<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/SPR-Step1/solid_examples/src/SingleResponsabilityPrinciple>
					o
						<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/SRP-Step2/solid_examples/src/SingleResponsabilityPrinciple>
		O
			Open/Closed Principle (OCP)
			Le principe ouvert/ferm√©
				L'OCP affirme qu'une une entit√© applicatif (classe, fonction, module, services, microservices, cas d'utilisation, ...) doit √™tre √† la fois ouverte (√† l'extension) et ferm√©e (√† la modification).
				L'id√©e est qu'une fois qu'une classe a √©t√© approuv√©e via des revues de code, des tests unitaires et d'autres proc√©dures de qualification, elle ne doit plus √™tre modifi√©e mais seulement √©tendue. 
				o
					En √©vitant de d√©pendre d'impl√©mentations sp√©cifiques,
					par l'utilisation des classes abstraites ou
					des interfaces.
				o
					Facilit√© d'ajout de nouveaux cas d'utilisation dans notre application.
				Example
					<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step1>
					Interfaces¬†¬†¬†https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step2 <https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step2>
					Abstract Class¬†¬†https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step3 <https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step3>
				Interfaces üÜö Classe abstraite
					Quand utiliser les interfaces ? 
						 lors du d√©couplage entre les couches¬†
												Avantages de l'interface :
													Ne modifie pas l'arbre hi√©rarchique
													Permet de mettre en ≈ìuvre N interfaces
											Quand utiliser Abstract ? 
						
						 Dans certains cas pour les mod√®les de domaine.
												Classe abstraite :
													Avantages :
														Permet de d√©velopper le pattern Template Method en poussant la logique vers le mod√®le.
															Patron de m√©thode
																Le Patron de m√©thode est un patron de conception comportemental qui permet de d√©finir le squelette d‚Äôun algorithme dans la classe de base, et laisse les sous-classes red√©finir les √©tapes sans modifier la structure globale de l‚Äôalgorithme.
																<https://refactoring.guru/fr/design-patterns/template-method/php/example>
													Probl√®me :
														Certains clients peuvent √™tre limit√©s √† cause du squelette de l‚Äôalgorithme.
														Vous ne respectez pas le Principe de substitution de Liskov, si vous supprimez l‚Äôimpl√©mentation d‚Äôune √©tape par d√©faut dans une sous-classe.
														Plus vous avez d‚Äô√©tapes, plus le patron de m√©thode devient difficile √† maintenir.
														Difficult√© de tra√ßage
														Getters priv√©s (Dites ne demandez pas)
		L
			Liskov's substitution principle (LSP)
			Principe de substitution de Liskov
				Le principe de substitution de Liskov est r√©ussi lorsqu'une m√©thode et toutes ses abstractions produisent les m√™mes effets secondaires et agissent sur les m√™mes propri√©t√©s.
				 Le fait de disposer d'une hi√©rarchie signifie que nous √©tablissons un contrat sur le parent. En veillant √† ce que ce contrat soit maintenu sur l'enfant, nous pouvons remplacer le parent et l'application continuera √† fonctionner parfaitement.
				o
					Maintenir la conformit√© fonctionnelle pour mettre en ≈ìuvre l'OCP.
				Le comportement des sous-classes doit respecter le contrat √©tabli dans la super-classe.
				Exemple
					As you can see I have to set the the creditcad to null and throw an exception when we are going to pay. It is evident that the program is really bad and the use of inheritance is already generating important problems. How can we solve this? See branch LSP-step2
						<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/LSP-step1/solid_examples>
					 In this case we have redefined the concept of Person to include less information. Now the kid is a Person since he/she always has a firstname and a lastname. It is the Adult class that incorporates the credit card to pay. This way everything is more reusable. If we want the kid to be able to pay something, he/she will do it delegating in the Adult class that is the one that can do it with the figure of tutor.  By executing the test the kid will be able to make a purchase if the tutor pays for it.
						<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/LSP-Step2/solid_examples>
		I
			Interface Segregation Principle (ISP)
				Concepto:
					Ning√∫n cliente deber√≠a verse forzado a depender de m√©todos que no usa
				C√≥mo:
					Definir contratos de interfaces bas√°ndonos en los clientes que las usan y no en las implementaciones que pudi√©ramos tener (Las interfaces pertenecen a los clientes)
					Evitar Header Interfaces promoviendo Role Interfaces
						o
							<https://martinfowler.com/bliki/HeaderInterface.html>
							<https://martinfowler.com/bliki/RoleInterface.html>
				Finalidad:
					Alta cohesi√≥n y bajo acoplamiento estructural
				Ejemplo Sencillo
					Queremos poder enviar notificaciones v√≠a email, Slack, o fichero txt ¬øQu√© firma tendr√° la interface? üì®
						a) $notifier($content)
						b) $notifier($slackChannel, $messageTitle, $messageContent, $messageStatus) ‚ùå
						c) $notifier($recieverEmail, $emailSubject, $emailContent) ‚ùå
						d) $notifier($destination, $subject, $content) ‚ùå
						e) $notifier($filename, $tag, $description) ‚ùå
					Podemos descartar que las opciones B, C y E fueran interfaces v√°lidas, puesto que se estar√≠a haciendo
					Header Interface en base a la implementaci√≥n (para Slack, email y fichero respectivamente).
					En el caso de la opci√≥n D, podr√≠amos considerarlo inv√°lido dado que el tipo $destination no nos ofrece ninguna especificidad (no sabemos si es un email, un canal‚Ä¶).
					Por √∫ltimo, en la opci√≥n A, s√≥lo estar√≠amos enviando el contenido, por lo que las particularidades de cada uno de los tipos de notificaci√≥n tendr√≠an que venir dados en el constructor (dependiendo del caso de uso no siempre se podr√≠a).
						Las interfaces pertenecen a los clientes y no a quienes las implementan
						Diferencia: Nivel de abstracci√≥n de la implementaci√≥n
							a) Si sabemos destinatario en tiempo de compilaci√≥n (par√°metros por constructor)
							d) Si no sabemos destinatario hasta tiempo de ejecuci√≥n (perdemos el tipado)
							f) Dos subscribers diferentes (email y slack) que leen de m√≥dulos‚Ä¶
				Ten√©is m√°s informaci√≥n relacionada con este principio en los siguientes videos de nuestro canal de Youtube:
					Principio de Segragaci√≥n de Interfaces
						<https://youtu.be/EzUIbMdxJTk>
					Errores comunes al dise√±ar Interfaces - #SOLID - ISP
						<https://youtu.be/mDAQLkdNGHU>
			Principe de s√©gr√©gation des interfaces
				 D√©clarer dans une interface des m√©thodes dont le client n'a pas besoin pollue l'interface et conduit √† une interface "volumineuse"
				 client ne doit pas √™tre expos√© √† des m√©thodes dont il n'a pas besoin
					Le ISP est tout particuli√®rement associ√© au principe de substitution de Liskov (LSP) et au principe de responsabilit√© unique (SRP).
					<https://reflectoring.io/interface-segregation-principle/>
				o
				o
				Exemple
					o
					o
		D
			Dependency Inversion Principle (DIP)
				Concepto:
					M√≥dulos de alto nivel no deber√≠an depender de los de bajo nivel. Ambos deber√≠an depender de abstracciones
				C√≥mo:
					Inyectar dependencias (par√°metros recibidos en constructor)
					Depender de las interfaces (contratos) de estas dependencias y no de implementaciones concretas
					LSP como premisa
				Finalidad:
					Facilitar la modificaci√≥n y substituci√≥n de implementaciones
					Mejor testabilidad de clases
					 Consejo:
					 Una forma de ver si estamos violando DIP es comprobar nuestras clases del Servicio de aplicaci√≥n si alguna de las dependencias est√° apuntando fuera de nuestro Dominio 
				¬øCu√°ndo deber√≠amos utilizar interfaces?
					Cuando tenemos que tocar algo de Entrada/Salida (Por ejemplo, nos interesar√° en tiempo de Test no tener que hacer una conexi√≥n real a BD)
					Cualquier escenario en el que necesitemos tolerancia al cambio
				Ejemplo Sencillo
					<https://github.com/CodelyTV/solid-principles-java-examples/tree/master/src/main/java/tv/codely/solid_principles/dependency_inversion_principle>
						Etapa 1 - Instanciaci√≥n desde los clientes
							En esta primera fase, estar√≠amos instanciando en la propia clase el repositorio que vamos a utilizar en el m√©todo search, es decir, cuando instanciemos nuestro UserSearcher, esta clase internamente estar√≠a haciendo un new de HardcodedInMemoryUsersRepository, lo cual nos lleva inevitablemente a estar fuertemente acoplados a dicho repositorio üîí.
							Desde el propio Test ya se observa este acoplamiento, obligando a saber, en este caso, que el usuario tiene que existir en el HashMap (caso de find_existing_users) o que no va a existir un usuario con un id concreto (caso de not_find_non_existing_users).
						Etapa 2.0 Inyecci√≥n de Dependencias üíâ
							Vamos un paso m√°s all√° en para reducir el acoplamiento en nuestra UserSearcher, para ello inyectaremos la dependencia que nuestra clase tiene respecto a HardcodedInMemoryUsersRepository en el propio constructor. De este modo, el punto de nuestro aplicaci√≥n que instancie a nuestro UserSearcher ser√° el responsable de saber c√≥mo debe hacerlo y que otras dependencias puede haber detr√°s.
							A nivel de Test observamos que, aunque no hemos ganado mucho en t√©rminos de acoplamiento, si que conseguimos exponer el acoplamiento de nuestras clases.
						Etapa 2.1 Inyecci√≥n de Dependencias de Par√°metros üíâ  
							Aunque la clase UserSearcher no ha cambiado, hemos dado un paso m√°s al realizar la inyecci√≥n de dependencias de forma recursiva con el HardcodedInMemoryUsersRepository, que ahora recibir√≠a como argumento en el constructor su atributo de clase users.
							Si echamos un vistazo a los Test, vemos c√≥mo ya no tenemos por qu√© saber qu√© usuarios existen en nuestro repositorio, por lo que conseguimos aislar nuestros Test sin que dependan de la infraestructura 
						Etapa 3 - Inversi√≥n de Dependencias ü§π‚Äç‚ôÄÔ∏è
							Vemos como ahora la clase UserSearcher lo que recibe por argumento en el constructor no es una implementaci√≥n de UserRepository, sino una interface que define √∫nicamente el contrato de un m√©todo search.
							A nivel de Test ya vemos c√≥mo podemos cambiar la implementaci√≥n de UserRepository sin necesidad de tocar nuestro UserSearcher,  es decir, podemos pasarle como argumento cualquier clase que implemente la interface.
						Conclusi√≥n
							Ahora el acoplamiento ir√° de nuestro caso de uso a la interface y las diferentes implementaciones se dirigir√°n hacia nuestra interface, en lugar de acoplar nuestro caso de uso a la implementaci√≥n.
			Principe d'inversion des d√©pendances
				o
				o
				o
				o
				Exemple
					o
					o
				Difference Between Inversion of Control and Dependency Injection
			 Dependency Injection
	[[+4 Beneficios de la composici√≥n sobre herencia]] 
		<https://github.com/CodelyTV/cqrs-ddd-php-example/blob/master/src/Mooc/Videos/Application/Create/VideoCreator.php>
		Como en el caso de nuestro VideoCreator, siempre que tengamos una dependencia y la estemos inyectando, hablar√≠amos de composici√≥n. Es decir, estamos compartiendo comportamiento a trav√©s de la composici√≥n.
		El beneficio que nos ofrece inyectar estas dependencias es que a nivel de Testing podremos ‚Äòfalsearlas‚Äô para evitar usar las reales que usar√≠amos en producci√≥n. Si por el contrario queremos testear una clase que herede de otra, nos estar√≠amos tragando inevitablemente la clase padre (Y por consiguiente tendr√≠amos que testear la clase padre en todos sus hijos).
		o
			Vamo a calmarno
				Usamos la herencia s√≥lo cuando sea indispensable
			Herencia para pocos modelos
			final por defecto
				Definiendo una clase como final evitamos que pueda extender
	[[+ 5 Entra√Ænement SOLID avec le kata GildedRose]]
		<https://kata-log.rocks/gilded-rose-kata>
