Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2022-08-24T00:25:09+02:00

====== 3 SOLID ======
Creado miÃ©rcoles 24 agosto 2022

[ ] TODO

==== S Single Responsqbility Principle (SRP) ====

== ğŸ”‘ï¸ ==
		Le principe de responsabilitÃ© unique 
			L'idÃ©e derriÃ¨re le SRP est que chaque classe, module ou fonction d'un programme doit avoir une responsabilitÃ©/un objectif dans le programme.
			"Chaque classe ne doit avoir qu'une seule raison de changer"
			o
				Petites classes avec de petits objectifs
				noms des mÃ©thodes et des classes bien prÃ©cis
					Afin de ne pas inciter Ã  l'ajout de plus de fonctionnalitÃ©s. 
					Exemple
						Ordre | User : Ce sont des modÃ¨les de domaine, pas des services.
						OrderAnalyzer | OrderProcessor : Ce sont des termes gÃ©nÃ©riques qui nous amÃ¨nent Ã  nous retrouver avec plus d'une responsabilitÃ©.
						OrderTrustabilityChecker | OrderMarginCalculator : Plus prÃ©cis. N'ouvre pas la porte Ã  l'ajout de nouvelles fonctionnalitÃ©s

=== **ğŸ¯ï¸** ===
				Haut niveau de cohÃ©sion et de robustesse.
				Favoriser la composition de classes (injecter des composants)
				Ã‰viter la duplication du code

				Test simplifiÃ©
					Une classe avec une seule responsabilitÃ© aura beaucoup moins de cas de test, ce qui permet de rÃ©duire les efforts de test.
				Faible couplage
					Moins de fonctionnalitÃ©s dans une seule classe aura moins de dÃ©pendances. Par consÃ©quent, le couplage sera rÃ©duit.
				Organisation plus efficace
					Les classes plus petites et bien organisÃ©es sont plus faciles Ã  rechercher par un lecteur de code dÃ©butant que les classes plus grandes.
				Plus simple Ã  intÃ©grer
					Les classes, les composants logiciels et les microservices qui n'ont qu'une seule responsabilitÃ© sont beaucoup plus faciles Ã  expliquer, Ã  comprendre et Ã  mettre en Å“uvre que ceux qui offrent une solution pour tout. Cela rÃ©duit le nombre de bugs, amÃ©liore votre vitesse de dÃ©veloppement et rend votre vie de dÃ©veloppeur de logiciels beaucoup plus facile.
				Plus simple Ã  maintenir
					En vous assurant que vos classes n'ont qu'une seule responsabilitÃ©, vous pouvez Ã©conomiser beaucoup d'efforts dans le dÃ©veloppement de l'application et crÃ©er une architecture plus facile Ã  maintenir.

=== ğŸ‘€ï¸ ===
			Example
				Supposons que nous Ã©crivions une application php pour un cabinet de conseil en recrutement. Nous allons crÃ©er une classe Resume qui permet au consultant d'obtenir et de dÃ©finir la technologie et les annÃ©es d'expÃ©rience dans chaque CV, et de rechercher le rÃ©sumÃ© Ã  partir de la base de donnÃ©es.
				o
					<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/SPR-Step1/solid_examples/src/SingleResponsabilityPrinciple>
				o
					<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/SRP-Step2/solid_examples/src/SingleResponsabilityPrinciple>

==== O Open/Closed Principle (OCP) ====

== ğŸ”‘ï¸ ==

=== **ğŸ¯ï¸** ===

=== ğŸ‘€ï¸ ===

		Le principe ouvert/fermÃ©
			L'OCP affirme qu'une une entitÃ© applicatif (classe, fonction, module, services, microservices, cas d'utilisation, ...) doit Ãªtre Ã  la fois ouverte (Ã  l'extension) et fermÃ©e (Ã  la modification).
			L'idÃ©e est qu'une fois qu'une classe a Ã©tÃ© approuvÃ©e via des revues de code, des tests unitaires et d'autres procÃ©dures de qualification, elle ne doit plus Ãªtre modifiÃ©e mais seulement Ã©tendue. 
			o
				En Ã©vitant de dÃ©pendre d'implÃ©mentations spÃ©cifiques,
				par l'utilisation des classes abstraites ou
				des interfaces.
			o
				FacilitÃ© d'ajout de nouveaux cas d'utilisation dans notre application.
			Example
				<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step1>
				InterfacesÂ Â Â https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step2 <https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step2>
				Abstract ClassÂ Â https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step3 <https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/OCP-Step3>
			Interfaces ğŸ†š Classe abstraite
				Quand utiliser les interfaces ? 

 lors du dÃ©couplage entre les couchesÂ 
					Avantages de l'interface :
						Ne modifie pas l'arbre hiÃ©rarchique
						Permet de mettre en Å“uvre N interfaces
				Quand utiliser Abstract ? 

 Dans certains cas pour les modÃ¨les de domaine.
					Classe abstraite :
						Avantages :
							Permet de dÃ©velopper le pattern Template Method en poussant la logique vers le modÃ¨le.
								Patron de mÃ©thode
									Le Patron de mÃ©thode est un patron de conception comportemental qui permet de dÃ©finir le squelette dâ€™un algorithme dans la classe de base, et laisse les sous-classes redÃ©finir les Ã©tapes sans modifier la structure globale de lâ€™algorithme.
									<https://refactoring.guru/fr/design-patterns/template-method/php/example>
						ProblÃ¨me :
							Certains clients peuvent Ãªtre limitÃ©s Ã  cause du squelette de lâ€™algorithme.
							Vous ne respectez pas le Principe de substitution de Liskov, si vous supprimez lâ€™implÃ©mentation dâ€™une Ã©tape par dÃ©faut dans une sous-classe.
							Plus vous avez dâ€™Ã©tapes, plus le patron de mÃ©thode devient difficile Ã  maintenir.
							DifficultÃ© de traÃ§age
							Getters privÃ©s (Dites ne demandez pas)

==== L Liskov's substitution principle (LSP) ====

== ğŸ”‘ï¸ ==

=== **ğŸ¯ï¸** ===

=== ğŸ‘€ï¸ ===


		Principe de substitution de Liskov
			Le principe de substitution de Liskov est rÃ©ussi lorsqu'une mÃ©thode et toutes ses abstractions produisent les mÃªmes effets secondaires et agissent sur les mÃªmes propriÃ©tÃ©s.
			 Le fait de disposer d'une hiÃ©rarchie signifie que nous Ã©tablissons un contrat sur le parent. En veillant Ã  ce que ce contrat soit maintenu sur l'enfant, nous pouvons remplacer le parent et l'application continuera Ã  fonctionner parfaitement.
			o
				Maintenir la conformitÃ© fonctionnelle pour mettre en Å“uvre l'OCP.
			Le comportement des sous-classes doit respecter le contrat Ã©tabli dans la super-classe.
			Exemple
				As you can see I have to set the the creditcad to null and throw an exception when we are going to pay. It is evident that the program is really bad and the use of inheritance is already generating important problems. How can we solve this? See branch LSP-step2
					<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/LSP-step1/solid_examples>
				 In this case we have redefined the concept of Person to include less information. Now the kid is a Person since he/she always has a firstname and a lastname. It is the Adult class that incorporates the credit card to pay. This way everything is more reusable. If we want the kid to be able to pay something, he/she will do it delegating in the Adult class that is the one that can do it with the figure of tutor.  By executing the test the kid will be able to make a purchase if the tutor pays for it.
					<https://github.com/smachara/SoftwareArchitectureCourseNotes/tree/LSP-Step2/solid_examples>

==== I Interface Segregation Principle (ISP) ====

== ğŸ”‘ï¸ ==

=== **ğŸ¯ï¸** ===

=== ğŸ‘€ï¸ ===

		Principe de sÃ©grÃ©gation des interfaces
			 DÃ©clarer dans une interface des mÃ©thodes dont le client n'a pas besoin pollue l'interface et conduit Ã  une interface "volumineuse"
			 client ne doit pas Ãªtre exposÃ© Ã  des mÃ©thodes dont il n'a pas besoin
				Le ISP est tout particuliÃ¨rement associÃ© au principe de substitution de Liskov (LSP) et au principe de responsabilitÃ© unique (SRP).
				<https://reflectoring.io/interface-segregation-principle/>

		Exemple
			
			[ ] TODO 
			
			
			
			Concepto:
				NingÃºn cliente deberÃ­a verse forzado a depender de mÃ©todos que no usa
			CÃ³mo:
				Definir contratos de interfaces basÃ¡ndonos en los clientes que las usan y no en las implementaciones que pudiÃ©ramos tener (Las interfaces pertenecen a los clientes)
				Evitar Header Interfaces promoviendo Role Interfaces
					o
						<https://martinfowler.com/bliki/HeaderInterface.html>
						<https://martinfowler.com/bliki/RoleInterface.html>
			Finalidad:
				Alta cohesiÃ³n y bajo acoplamiento estructural
			Ejemplo Sencillo
				Queremos poder enviar notificaciones vÃ­a email, Slack, o fichero txt Â¿QuÃ© firma tendrÃ¡ la interface? ğŸ“¨
					a) $notifier($content)
					b) $notifier($slackChannel, $messageTitle, $messageContent, $messageStatus) âŒ
					c) $notifier($recieverEmail, $emailSubject, $emailContent) âŒ
					d) $notifier($destination, $subject, $content) âŒ
					e) $notifier($filename, $tag, $description) âŒ
				Podemos descartar que las opciones B, C y E fueran interfaces vÃ¡lidas, puesto que se estarÃ­a haciendo
				Header Interface en base a la implementaciÃ³n (para Slack, email y fichero respectivamente).
				En el caso de la opciÃ³n D, podrÃ­amos considerarlo invÃ¡lido dado que el tipo $destination no nos ofrece ninguna especificidad (no sabemos si es un email, un canalâ€¦).
				Por Ãºltimo, en la opciÃ³n A, sÃ³lo estarÃ­amos enviando el contenido, por lo que las particularidades de cada uno de los tipos de notificaciÃ³n tendrÃ­an que venir dados en el constructor (dependiendo del caso de uso no siempre se podrÃ­a).
					Las interfaces pertenecen a los clientes y no a quienes las implementan
					Diferencia: Nivel de abstracciÃ³n de la implementaciÃ³n
						a) Si sabemos destinatario en tiempo de compilaciÃ³n (parÃ¡metros por constructor)
						d) Si no sabemos destinatario hasta tiempo de ejecuciÃ³n (perdemos el tipado)
						f) Dos subscribers diferentes (email y slack) que leen de mÃ³dulosâ€¦
			TenÃ©is mÃ¡s informaciÃ³n relacionada con este principio en los siguientes videos de nuestro canal de Youtube:
				Principio de SegragaciÃ³n de Interfaces
					<https://youtu.be/EzUIbMdxJTk>
				Errores comunes al diseÃ±ar Interfaces - #SOLID - ISP
					<https://youtu.be/mDAQLkdNGHU>



==== D Dependency Inversion Principle (DIP) ====

== ğŸ”‘ï¸ ==

=== **ğŸ¯ï¸** ===

=== ğŸ‘€ï¸ ===

			[ ] TODO 
		
			Concepto:
				MÃ³dulos de alto nivel no deberÃ­an depender de los de bajo nivel. Ambos deberÃ­an depender de abstracciones
			CÃ³mo:
				Inyectar dependencias (parÃ¡metros recibidos en constructor)
				Depender de las interfaces (contratos) de estas dependencias y no de implementaciones concretas
				LSP como premisa
			Finalidad:
				Facilitar la modificaciÃ³n y substituciÃ³n de implementaciones
				Mejor testabilidad de clases
				 Consejo:
				 Una forma de ver si estamos violando DIP es comprobar nuestras clases del Servicio de aplicaciÃ³n si alguna de las dependencias estÃ¡ apuntando fuera de nuestro Dominio 
			Â¿CuÃ¡ndo deberÃ­amos utilizar interfaces?
				Cuando tenemos que tocar algo de Entrada/Salida (Por ejemplo, nos interesarÃ¡ en tiempo de Test no tener que hacer una conexiÃ³n real a BD)
				Cualquier escenario en el que necesitemos tolerancia al cambio
			Ejemplo Sencillo
				<https://github.com/CodelyTV/solid-principles-java-examples/tree/master/src/main/java/tv/codely/solid_principles/dependency_inversion_principle>
					Etapa 1 - InstanciaciÃ³n desde los clientes
						En esta primera fase, estarÃ­amos instanciando en la propia clase el repositorio que vamos a utilizar en el mÃ©todo search, es decir, cuando instanciemos nuestro UserSearcher, esta clase internamente estarÃ­a haciendo un new de HardcodedInMemoryUsersRepository, lo cual nos lleva inevitablemente a estar fuertemente acoplados a dicho repositorio ğŸ”’.
						Desde el propio Test ya se observa este acoplamiento, obligando a saber, en este caso, que el usuario tiene que existir en el HashMap (caso de find_existing_users) o que no va a existir un usuario con un id concreto (caso de not_find_non_existing_users).
					Etapa 2.0 InyecciÃ³n de Dependencias ğŸ’‰
						Vamos un paso mÃ¡s allÃ¡ en para reducir el acoplamiento en nuestra UserSearcher, para ello inyectaremos la dependencia que nuestra clase tiene respecto a HardcodedInMemoryUsersRepository en el propio constructor. De este modo, el punto de nuestro aplicaciÃ³n que instancie a nuestro UserSearcher serÃ¡ el responsable de saber cÃ³mo debe hacerlo y que otras dependencias puede haber detrÃ¡s.
						A nivel de Test observamos que, aunque no hemos ganado mucho en tÃ©rminos de acoplamiento, si que conseguimos exponer el acoplamiento de nuestras clases.
					Etapa 2.1 InyecciÃ³n de Dependencias de ParÃ¡metros ğŸ’‰  
						Aunque la clase UserSearcher no ha cambiado, hemos dado un paso mÃ¡s al realizar la inyecciÃ³n de dependencias de forma recursiva con el HardcodedInMemoryUsersRepository, que ahora recibirÃ­a como argumento en el constructor su atributo de clase users.
						Si echamos un vistazo a los Test, vemos cÃ³mo ya no tenemos por quÃ© saber quÃ© usuarios existen en nuestro repositorio, por lo que conseguimos aislar nuestros Test sin que dependan de la infraestructura 
					Etapa 3 - InversiÃ³n de Dependencias ğŸ¤¹â€â™€ï¸
						Vemos como ahora la clase UserSearcher lo que recibe por argumento en el constructor no es una implementaciÃ³n de UserRepository, sino una interface que define Ãºnicamente el contrato de un mÃ©todo search.
						A nivel de Test ya vemos cÃ³mo podemos cambiar la implementaciÃ³n de UserRepository sin necesidad de tocar nuestro UserSearcher,  es decir, podemos pasarle como argumento cualquier clase que implemente la interface.
					ConclusiÃ³n
						Ahora el acoplamiento irÃ¡ de nuestro caso de uso a la interface y las diferentes implementaciones se dirigirÃ¡n hacia nuestra interface, en lugar de acoplar nuestro caso de uso a la implementaciÃ³n.
		
		Principe d'inversion des dÃ©pendances
			Exemple
			Difference Between Inversion of Control and Dependency Injection
		   Dependency Injection

